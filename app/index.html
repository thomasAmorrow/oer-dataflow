<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Leaflet GeoJSON Polygons with Canvas & Viewport Filtering</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/d3-scale-chromatic@3.0.0/dist/d3-scale-chromatic.min.js"></script>
  <style>
    #map { width: 100%; height: 800px; }

    #colorbar {
      position: absolute;
      bottom: 20px;
      left: 20px;
      z-index: 1000;
      background: white;
      padding: 10px;
      border-radius: 5px;
      font-family: sans-serif;
      box-shadow: 0 0 5px rgba(0,0,0,0.3);
      width: 300px;
    }

    #colorbar svg {
      display: block;
      width: 100%;
      height: 20px;
    }

    #colorbar-labels {
      display: flex;
      justify-content: space-between;
      font-size: 10px;
      margin-top: 4px;
    }
  </style>
</head>
<body>
  <div id="map"></div>

  <!-- Horizontal Colorbar -->
  <div id="colorbar">
    <div style="font-size: 12px; margin-bottom: 5px;">Exploration Score</div>
    <svg></svg>
    <div id="colorbar-labels">
      <span>0</span>
      <span>&gt; 0.2</span>
    </div>
  </div>

  <script>
    const map = L.map('map', {
      worldCopyJump: true
    });

    // Base layer
    L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
      attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community'
    }).addTo(map);

    // Color scale (perceptual Lab interpolation)
    const color = d3.scaleLinear()
      .domain([0, 0.25, 0.5, 0.75, 1])
      .range(["#001743", "#001743", "#003087", "#34bddf", "white"])
      .interpolate(d3.interpolateLab);

    function getColor(value) {
      const flipped = 1 - value;
      const transformed = Math.pow(flipped, 4);
      return color(transformed);
    }

    // Canvas renderer for performance
    const canvasRenderer = L.canvas({ padding: 0.5 });

    // Variables to hold all wrapped features and current layer
    let allWrappedFeatures = [];
    let currentLayer = null;

    // Helper: add longitude wrapping (Â±360)
    function createWrappedFeatures(features) {
      const wrapped = [];
      features.forEach(feature => {
        wrapped.push(feature); // original
        [-360, 360].forEach(offset => {
          const newFeature = JSON.parse(JSON.stringify(feature));
          if (newFeature.geometry.type === 'Polygon') {
            newFeature.geometry.coordinates = newFeature.geometry.coordinates.map(ring =>
              ring.map(([lng, lat]) => [lng + offset, lat])
            );
          } else if (newFeature.geometry.type === 'MultiPolygon') {
            newFeature.geometry.coordinates = newFeature.geometry.coordinates.map(polygon =>
              polygon.map(ring =>
                ring.map(([lng, lat]) => [lng + offset, lat])
              )
            );
          }
          wrapped.push(newFeature);
        });
      });
      return wrapped;
    }

    // Filter features that intersect current map bounds (with buffer)
    function filterFeaturesByBounds(bounds, features) {
      // Add buffer in degrees (to avoid flicker when panning)
      const bufferDegrees = 1.5;
      const bufferedBounds = bounds.pad(bufferDegrees / (bounds.getNorth() - bounds.getSouth()));

      return features.filter(feature => {
        const featureBounds = L.geoJSON(feature).getBounds();
        return bufferedBounds.intersects(featureBounds);
      });
    }

    // Update the displayed layer with features inside the current map bounds
    function updateLayer() {
      const bounds = map.getBounds();
      const visibleFeatures = filterFeaturesByBounds(bounds, allWrappedFeatures);

      if (currentLayer) {
        map.removeLayer(currentLayer);
      }

      currentLayer = L.geoJSON({
        type: 'FeatureCollection',
        features: visibleFeatures
      }, {
        renderer: canvasRenderer,
        style: function(feature) {
          const value = feature.properties.combined ?? 0;
          return {
            color: getColor(value),
            weight: 1,
            opacity: 0.8,
            fillOpacity: 0.1,
            fill: true
          };
        },
        onEachFeature: function(feature, layer) {
          layer.bindPopup(function () {
            let popupContent = '<strong>Polygon Properties</strong><br>';
            for (const key in feature.properties) {
              popupContent += `${key}: ${feature.properties[key]}<br>`;
            }
            return popupContent;
          });

          layer.on({
            mouseover: function () {
              layer.setStyle({
                weight: 3,
                fillOpacity: 0.3
              });
              layer.bringToFront();
            },
            mouseout: function () {
              layer.setStyle({
                weight: 1,
                fillOpacity: 0.1
              });
            }
          });
        }
      }).addTo(map);
    }

    // Load GeoJSON, wrap features, and initialize map layer + event handlers
    fetch('http://localhost:8000/geo/h3_hexagons_03.geojson')
      .then(res => res.json())
      .then(geojson => {
        allWrappedFeatures = createWrappedFeatures(geojson.features);

        // Initially fit map to original data bounds (no wrapping)
        //const originalLayer = L.geoJSON(geojson);
        //map.fitBounds(originalLayer.getBounds());

        // Initial render
        updateLayer();

        // Update layer on map move/zoom end
        map.on('moveend', updateLayer);
      })
      .catch(err => console.error('Error loading GeoJSON:', err));

    // Create horizontal colorbar
    const svg = d3.select("#colorbar svg");
    const width = 300;
    const height = 20;
    const n = 20;

    const data = d3.range(n).map(i => i / (n - 1));

    // Set initial map center & zoom (will be overridden by fitBounds on data load)
    map.setView([25, -130], 4);

    svg.selectAll("rect")
      .data(data)
      .enter().append("rect")
      .attr("x", (d, i) => i * width / n)
      .attr("y", 0)
      .attr("width", width / n)
      .attr("height", height)
      .attr("fill", d => color(Math.pow(1 - d, 4))); // match transformed scale
  </script>
</body>
</html>
