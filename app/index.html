<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>NOAA Ocean Exploration Gap Analysis</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/d3-scale-chromatic@3.0.0/dist/d3-scale-chromatic.min.js"></script>
  <style>
    /* Roboto font from Google Fonts */
    @import url('https://fonts.googleapis.com/css2?family=Roboto&display=swap');

    body {
      margin: 0;
      background-color: #121212;
      color: #eee;
      font-family: 'Roboto', sans-serif;
      display: flex;
      height: 100vh;
      overflow: hidden;
      flex-direction: row-reverse; /* keep sidebar on right */
    }

    #sidebar {
      width: clamp(240px, 25vw, 320px);
      background: #1e1e1e;
      box-shadow: -3px 0 10px rgba(0,0,0,0.7); /* shadow on left for right sidebar */
      padding: 20px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 1em;
    }

    #sidebar img {
      width: 100%;
      height: auto;
      margin-bottom: 15px;
      object-fit: contain;
    }

    #sidebar h2 {
      margin: 0 0 10px 0;
      font-weight: 700;
      color: #ffffff;
      text-align: center; 
    }

    #sidebar table {
      width: 100%;
      border-collapse: collapse;
    }

    #sidebar td {
      padding: 6px 8px;
      border-bottom: 1px solid #333;
    }

    #sidebar td:first-child {
      color: #77ccee;
      font-weight: 500;
    }

    #map {
      flex-grow: 1;
      height: 100vh;
      overflow: hidden;
    }

    #map:focus {
      outline: none;
      box-shadow: none;
    }

    #colorbar {
      position: absolute;
      bottom: 20px;
      left: 20px;
      z-index: 1000;
      background: #1e1e1e;
      padding: 10px;
      border-radius: 5px;
      font-family: 'Roboto', sans-serif;
      box-shadow: 0 0 5px rgba(0,0,0,0.7);
      width: 300px;
      color: #eee;
    }

    #colorbar svg {
      display: block;
      width: 100%;
      height: 20px;
    }

    #colorbar-labels {
      display: flex;
      justify-content: space-between;
      font-size: 10px;
      margin-top: 4px;
      color: #bbb;
    }

    details summary {
      cursor: pointer;
      font-weight: bold;
      margin-bottom: 4px;
      color: #34bddf;
    }

    /* Popup styling */
    .leaflet-popup-content table td {
      padding: 2px 5px;
      border-bottom: 1px solid #ddd;
      color: #222;
    }

    .leaflet-popup-content details summary {
      color: #34bddf;
      cursor: pointer;
    }
  </style>
</head>
<body>

  <div id="sidebar">
    <img src="https://github.com/NOAA-OceanExploration/ExplorationGapAnalysis/blob/main/docs/logos/logo.png?raw=true" 
         alt="NOAA Ocean Exploration Logo" />
    <h2>Visible Polygon Averages</h2>
    <table id="stats-table">
      <tbody>
        <tr><td>Loading...</td></tr>
      </tbody>
    </table>
    <div id="sidebar-context" style="margin-top: auto; font-size: 16px; color: #ffffff; line-height: 1.4;">
      <p>
        This map displays <a href="https://oceanexplorer.noaa.gov/" target="_blank" rel="noopener noreferrer" style="color: #34bddf; text-decoration: none;">NOAA Ocean Exploration</a> Gap Analysis scores. Higher scores mean more explored areas; lower scores indicate less explored. White bordered hexagons have no observations (unexplored). The dynamic table shows average scores for hexagons visible on the map.
      </p>
      <p>
        Source and code available on the 
        <a href="https://github.com/NOAA-OceanExploration/ExplorationGapAnalysis" target="_blank" rel="noopener noreferrer" style="color: #34bddf; text-decoration: none;">
          NOAA-OceanExploration GitHub</a> along with higher resolution results.
      </p>
    </div>
  </div>

  <div id="map"></div>

  <div id="colorbar">
    <div style="font-size: 12px; margin-bottom: 5px;">Exploration Score</div>
    <svg></svg>
    <div id="colorbar-labels">
      <span>unexplored</span>
      <span>more explored</span>
    </div>
  </div>

  <script>
    // Mapping JSON property keys to friendly labels
    const propertyLabels = {
      h3_index: "H3 Hexagon",
      geology: "Geological Sampling",
      combined: "Total Exploration Score",
      mapping: "Hi-Rez Mapping",
      chemistry: "Water Chemistry",
      occurrence: "Biological Sampling",
      edna_score: "eDNA Sequencing",
      wcsd_score: "Water Column Mapping"
      // Add more custom labels here if you want
      // e.g. 'oceanDepth': 'Ocean Depth (m)',
    };

    const map = L.map('map', {
      worldCopyJump: true,
      attributionControl: false,
    });

    L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
      attribution: ''
    }).addTo(map);

    L.control.attribution({
      prefix: false  // remove 'Leaflet' link prefix
    }).addAttribution('Map powered by Leaflet | Imagery Â© Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and GIS User Community')
      .addTo(map);

    const color = d3.scaleLinear()
      .domain([0, 0.25, 0.5, 0.75, 1])
      .range(["#001743", "#001743", "#003087", "#34bddf", "white"])
      .interpolate(d3.interpolateLab);

    function getColor(value) {
      const flipped = 1 - value;
      const transformed = Math.pow(flipped, 4);
      return color(transformed);
    }

    const canvasRenderer = L.canvas({ padding: 0.5 });
    let allWrappedFeatures = [];
    let currentLayer = null;

    function createWrappedFeatures(features) {
      const wrapped = [];
      features.forEach(feature => {
        wrapped.push(feature);
        [-360, 360].forEach(offset => {
          const newFeature = JSON.parse(JSON.stringify(feature));
          if (newFeature.geometry.type === 'Polygon') {
            newFeature.geometry.coordinates = newFeature.geometry.coordinates.map(ring =>
              ring.map(([lng, lat]) => [lng + offset, lat])
            );
          } else if (newFeature.geometry.type === 'MultiPolygon') {
            newFeature.geometry.coordinates = newFeature.geometry.coordinates.map(polygon =>
              polygon.map(ring =>
                ring.map(([lng, lat]) => [lng + offset, lat])
              )
            );
          }
          wrapped.push(newFeature);
        });
      });
      return wrapped;
    }

    function filterFeaturesByBounds(bounds, features) {
      const bufferDegrees = 1.5;
      const bufferedBounds = bounds.pad(bufferDegrees / (bounds.getNorth() - bounds.getSouth()));

      return features.filter(feature => {
        const featureBounds = L.geoJSON(feature).getBounds();
        return bufferedBounds.intersects(featureBounds);
      });
    }

    // Update sidebar stats with averages of visible polygon properties
    function updateSidebarStats(visibleFeatures) {
      if (!visibleFeatures.length) {
        document.querySelector("#stats-table tbody").innerHTML = "<tr><td>No visible polygons</td></tr>";
        return;
      }

      const keys = Object.keys(visibleFeatures[0].properties).filter(k => k !== 'h3_index');
      const sums = {};
      keys.forEach(k => sums[k] = 0);

      visibleFeatures.forEach(f => {
        keys.forEach(k => {
          const val = f.properties[k];
          sums[k] += (typeof val === 'number') ? val : 0;
        });
      });

      const counts = visibleFeatures.length;
      let html = "";
      keys.forEach(key => {
        const avg = sums[key] / counts;
        const widthPercent = Math.min((avg / 1) * 100, 100); // Assuming max score is 1

        // First row: label and number
        html += `
          <tr>
            <td>${propertyLabels[key] || key}</td>
            <td style="text-align: right; font-weight: bold; color: #eee;">${avg.toFixed(3)}</td>
          </tr>
        `;

        // Second row: bar spanning both columns, bar offset to align under number column
        html += `
          <tr>
            <td colspan="2" style="padding: 0;">
              <div style="position: relative; width: 100%; height: 12px; background: #333; border-radius: 3px; overflow: hidden;">
                <div style="
                  position: absolute;
                  top: 0; bottom: 0;
                  left: 0%; /* start bar at midpoint (label col width approx) */
                  width: ${widthPercent / 2}%; /* scale bar width relative to half table */
                  background: #34bddf;
                  border-radius: 3px 0 0 3px;
                "></div>
              </div>
            </td>
          </tr>
        `;
      });

      document.querySelector("#stats-table tbody").innerHTML = html;
    }


    function updateLayer() {
      const bounds = map.getBounds();
      const visibleFeatures = filterFeaturesByBounds(bounds, allWrappedFeatures);

      if (currentLayer) {
        map.removeLayer(currentLayer);
      }

      currentLayer = L.geoJSON({
        type: 'FeatureCollection',
        features: visibleFeatures
      }, {
        renderer: canvasRenderer,
        style: function(feature) {
          const value = feature.properties.combined ?? 0;
          return {
            color: getColor(value),
            weight: value === 0 ? 1 : 0.25,
            opacity: 1.0,
            fillOpacity: 0.25,
            fill: true
          };
        },
        onEachFeature: function(feature, layer) {
          layer.bindPopup(function () {
            const detailedKeys = Object.keys(feature.properties);
            let popupContent = `<details open>
              <summary>Polygon Properties</summary>
              <table>`;
            detailedKeys.forEach(key => {
              const val = feature.properties[key];
              popupContent += `
                <tr>
                  <td><strong>${propertyLabels[key] || key}</strong></td>
                  <td>${
                    typeof val === 'number'
                      ? val.toFixed(3)
                      : val
                  }</td>
                </tr>`;
            });
            popupContent += `</table></details>`;
            return popupContent;
          });

          layer.on({
            mouseover: function () {
              layer.setStyle({
                weight: 4,
                opacity: 1.0,
                fillOpacity: 0.6
              });
              layer.bringToFront();
            },
            mouseout: function () {
              const value = feature.properties.combined ?? 0;
              layer.setStyle({
                weight: value === 0 ? 1 : 0.25,
                opacity: 1.0,
                fillOpacity: 0.25,
              });
            }
          });
        }
      }).addTo(map);

      // Update the sidebar averages
      updateSidebarStats(visibleFeatures);
    }

    fetch('http://localhost:8000/geo/h3_hexagons_03.geojson')
      .then(res => res.json())
      .then(geojson => {
        allWrappedFeatures = createWrappedFeatures(geojson.features);
        updateLayer();
        map.on('moveend', updateLayer);
      })
      .catch(err => console.error('Error loading GeoJSON:', err));

    const svg = d3.select("#colorbar svg");
    const width = 300;
    const height = 20;
    const n = 20;

    const data = d3.range(n).map(i => i / (n - 1));

    map.setView([25, -130], 4);

    svg.selectAll("rect")
      .data(data)
      .enter().append("rect")
      .attr("x", (d, i) => i * width / n)
      .attr("y", 0)
      .attr("width", width / n)
      .attr("height", height)
      .attr("fill", d => color(Math.pow(1 - d, 1)));
  </script>
</body>
</html>
